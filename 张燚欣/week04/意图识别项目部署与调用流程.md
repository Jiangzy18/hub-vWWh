ğŸ“é¡¹ç›®ç»“æ„æ¦‚è§ˆ
text
intent_recognition_project/
â”œâ”€â”€ data/                    # æ•°æ®é›†
â”œâ”€â”€ models/                  # æ¨¡å‹æ–‡ä»¶
â”œâ”€â”€ src/                    # æ ¸å¿ƒæºä»£ç 
â”œâ”€â”€ configs/                # é…ç½®æ–‡ä»¶
â”œâ”€â”€ api/                    # APIæœåŠ¡
â”œâ”€â”€ tests/                  # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ requirements.txt        # ä¾èµ–åŒ…
â”œâ”€â”€ train.py               # è®­ç»ƒè„šæœ¬
â””â”€â”€ inference.py           # æ¨ç†è„šæœ¬
ğŸ”§ ç¬¬ä¸€ç« ï¼šç¯å¢ƒé…ç½®
1.1 ç³»ç»Ÿè¦æ±‚
æ“ä½œç³»ç»Ÿ: Ubuntu 20.04+/Windows 10/WSL2

Pythonç‰ˆæœ¬: 3.8+

å†…å­˜: â‰¥8GB RAM

å­˜å‚¨: â‰¥10GB å¯ç”¨ç©ºé—´

1.2 è™šæ‹Ÿç¯å¢ƒåˆ›å»º
bash
# æ–¹æ³•ä¸€ï¼šä½¿ç”¨ venv
python -m venv venv_intent
source venv_intent/bin/activate  # Linux/Mac
# venv_intent\Scripts\activate  # Windows

# æ–¹æ³•äºŒï¼šä½¿ç”¨ conda
conda create -n intent_env python=3.8
conda activate intent_env
1.3 ä¾èµ–å®‰è£…
bash
# åˆ›å»º requirements.txt
cat > requirements.txt << EOF
torch>=2.0.0
transformers==4.30.0
flask==2.3.0
flask-cors==4.0.0
numpy>=1.24.0
pandas>=2.0.0
scikit-learn>=1.2.0
jieba>=0.42.1
EOF

# å®‰è£…ä¾èµ–
pip install -r requirements.txt
âš™ï¸ ç¬¬äºŒç« ï¼šé…ç½®æ–‡ä»¶
2.1 é…ç½®å†…å®¹ (configs/config.yaml)
yaml
model:
  name: "bert-base-chinese"
  max_length: 128
  num_labels: 10
  dropout_rate: 0.3

training:
  batch_size: 16
  epochs: 10
  learning_rate: 2e-5
  warmup_steps: 100

data:
  train_path: "data/train.csv"
  test_path: "data/test.csv"
  intent_labels: 
    - "æŸ¥è¯¢"
    - "é¢„è®¢"
    - "å–æ¶ˆ"
    - "æŠ•è¯‰"
    - "è¡¨æ‰¬"
    - "å’¨è¯¢"
    - "å»ºè®®"
    - "æ±‚åŠ©"
    - "é—²èŠ"
    - "å…¶ä»–"

api:
  host: "0.0.0.0"
  port: 5000
  debug: true
ğŸ’» ç¬¬ä¸‰ç« ï¼šæ ¸å¿ƒä»£ç æ¨¡å—
3.1 æ•°æ®å¤„ç†å™¨ (src/data_processor.py)
python
class DataProcessor:
    """
    åŠŸèƒ½ï¼šæ•°æ®åŠ è½½ã€é¢„å¤„ç†ã€ç¼–ç 
    æ ¸å¿ƒæ–¹æ³•ï¼š
    1. load_data() - åŠ è½½CSVæ•°æ®
    2. preprocess_text() - ä¸­æ–‡åˆ†è¯å¤„ç†
    3. encode_texts() - BERT tokenizerç¼–ç 
    4. get_label_map() - æ ‡ç­¾æ˜ å°„
    """
3.2 æ„å›¾è¯†åˆ«æ¨¡å‹ (src/model.py)
python
class IntentRecognitionModel(nn.Module):
    """
    åŸºäºBERTçš„æ„å›¾åˆ†ç±»æ¨¡å‹ç»“æ„ï¼š
    BERT â†’ Dropout â†’ Linear Classifier
    
    è¾“å…¥ï¼šinput_ids, attention_mask
    è¾“å‡ºï¼šnum_labelsç»´åº¦çš„logits
    """
3.3 é¢„æµ‹å™¨ (src/predictor.py)
python
class IntentPredictor:
    """
    åŠŸèƒ½ï¼šåŠ è½½è®­ç»ƒå¥½çš„æ¨¡å‹è¿›è¡Œé¢„æµ‹
    æ ¸å¿ƒæ–¹æ³•ï¼š
    predict(text) -> {
        "intent": "é¢„è®¢",
        "confidence": 0.9567,
        "text": "åŸå§‹æ–‡æœ¬"
    }
    """
ğŸš€ ç¬¬å››ç« ï¼šæ¨¡å‹è®­ç»ƒä¸æµ‹è¯•
4.1 è®­ç»ƒæ‰§è¡Œå‘½ä»¤
bash
# 1. å‡†å¤‡æ•°æ®ï¼ˆç¤ºä¾‹ï¼‰
python scripts/create_sample_data.py

# 2. å¼€å§‹è®­ç»ƒ
python train.py

# è¾“å‡ºç¤ºä¾‹ï¼š
# Epoch [1/10], Loss: 1.2345, Accuracy: 0.4567
# ...
# æ¨¡å‹è®­ç»ƒå®Œæˆï¼Œå‡†ç¡®ç‡ï¼š0.8923
4.2 è®­ç»ƒæµç¨‹







ğŸŒ ç¬¬äº”ç« ï¼šAPIæœåŠ¡éƒ¨ç½²
5.1 Flask APIæœåŠ¡ (api/app.py)
python
# æ ¸å¿ƒæ¥å£
@app.route('/predict', methods=['POST'])
def predict():
    """
    å•æ¡æ„å›¾é¢„æµ‹æ¥å£
    è¯·æ±‚: {"text": "æˆ‘æƒ³é¢„è®¢é…’åº—"}
    å“åº”: {
        "success": true,
        "data": {
            "intent": "é¢„è®¢",
            "confidence": 0.9567
        }
    }
    """
5.2 å¯åŠ¨APIæœåŠ¡
bash
# å¼€å‘æ¨¡å¼
python api/app.py
# è¾“å‡º: Running on http://0.0.0.0:5000

# ç”Ÿäº§æ¨¡å¼ï¼ˆä½¿ç”¨gunicornï¼‰
pip install gunicorn
gunicorn -w 4 -b 0.0.0.0:5000 api.app:app
ğŸ“¡ ç¬¬å…­ç« ï¼šæœåŠ¡è°ƒç”¨æµ‹è¯•
6.1 Pythonå®¢æˆ·ç«¯è°ƒç”¨
python
import requests

client = IntentRecognitionClient()

# å•ä¸ªé¢„æµ‹
result = client.predict("æˆ‘æƒ³é¢„è®¢æ˜å¤©çš„é¤å…")
print(result["data"]["intent"])  # è¾“å‡º: "é¢„è®¢"

# æ‰¹é‡é¢„æµ‹
results = client.batch_predict([
    "å¦‚ä½•é€€è®¢",
    "æŸ¥è¯¢è®¢å•",
    "æˆ‘è¦æŠ•è¯‰"
])
6.2 å‘½ä»¤è¡Œè°ƒç”¨ï¼ˆcurlï¼‰
bash
# å•ä¸ªé¢„æµ‹
curl -X POST http://localhost:5000/predict \
  -H "Content-Type: application/json" \
  -d '{"text": "æˆ‘æƒ³é¢„è®¢é…’åº—"}'

# æ‰¹é‡é¢„æµ‹
curl -X POST http://localhost:5000/batch_predict \
  -H "Content-Type: application/json" \
  -d '{"texts": ["æŸ¥è¯¢", "æŠ•è¯‰", "å’¨è¯¢"]}'

# å¥åº·æ£€æŸ¥
curl http://localhost:5000/health
6.3 è¿”å›ç»“æœç¤ºä¾‹
json
{
  "success": true,
  "data": {
    "intent": "é¢„è®¢",
    "confidence": 0.9567,
    "text": "æˆ‘æƒ³é¢„è®¢æ˜å¤©çš„é…’åº—"
  }
}
ğŸ³ ç¬¬ä¸ƒç« ï¼šDockerå®¹å™¨åŒ–éƒ¨ç½²ï¼ˆå¯é€‰ï¼‰
7.1 Dockerfile
dockerfile
# åŸºç¡€é•œåƒ
FROM python:3.8-slim

# å·¥ä½œç›®å½•
WORKDIR /app

# å®‰è£…ä¾èµ–
COPY requirements.txt .
RUN pip install -r requirements.txt

# å¤åˆ¶ä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 5000

# å¯åŠ¨å‘½ä»¤
CMD ["python", "api/app.py"]
7.2 Docker Composeé…ç½®
yaml
version: '3.8'
services:
  intent-api:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - ./models:/app/models
    restart: unless-stopped
7.3 Dockeréƒ¨ç½²å‘½ä»¤
bash
# æ„å»ºé•œåƒ
docker build -t intent-api .

# è¿è¡Œå®¹å™¨
docker run -p 5000:5000 intent-api

# ä½¿ç”¨docker-compose
docker-compose up -d
ğŸ” ç¬¬å…«ç« ï¼šç›‘æ§ä¸è°ƒè¯•
8.1 æ—¥å¿—é…ç½®
python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/api.log'),
        logging.StreamHandler()
    ]
)
8.2 æ€§èƒ½ç›‘æ§æŒ‡æ ‡
bash
# APIå“åº”æ—¶é—´
# è¯·æ±‚æˆåŠŸç‡
# æ¨¡å‹æ¨ç†è€—æ—¶
# å†…å­˜ä½¿ç”¨æƒ…å†µ
âš¡ ç¬¬ä¹ç« ï¼šæ€§èƒ½ä¼˜åŒ–
9.1 æ¨¡å‹ä¼˜åŒ–ç­–ç•¥
ç­–ç•¥	æ•ˆæœ	å®ç°æ–¹å¼
æ¨¡å‹é‡åŒ–	å‡å°‘å†…å­˜50-75%	torch.quantization
å±‚å‰ªæ	å‡å°‘å‚æ•°30-50%	ç§»é™¤ä¸é‡è¦çš„æƒé‡
çŸ¥è¯†è’¸é¦	å°æ¨¡å‹+é«˜ç²¾åº¦	æ•™å¸ˆ-å­¦ç”Ÿæ¨¡å‹
9.2 APIä¼˜åŒ–æ–¹æ¡ˆ
è¯·æ±‚ç¼“å­˜ - å¯¹ç›¸åŒæŸ¥è¯¢ç¼“å­˜ç»“æœ

æ‰¹é‡å¤„ç† - æ”¯æŒæ‰¹é‡é¢„æµ‹å‡å°‘å¼€é”€

å¼‚æ­¥å¤„ç† - ä½¿ç”¨Celeryå¤„ç†é•¿ä»»åŠ¡

è¿æ¥æ±  - æ•°æ®åº“/å¤–éƒ¨æœåŠ¡è¿æ¥å¤ç”¨

ğŸ› ç¬¬åç« ï¼šå¸¸è§é—®é¢˜æ’æŸ¥
é—®é¢˜1ï¼šCUDAå†…å­˜ä¸è¶³
bash
# è§£å†³æ–¹æ¡ˆ
export CUDA_VISIBLE_DEVICES=0  # æŒ‡å®šGPU
# ä»£ç ä¸­æ·»åŠ 
torch.cuda.empty_cache()
é—®é¢˜2ï¼šç«¯å£è¢«å ç”¨
bash
# æŸ¥æ‰¾å ç”¨è¿›ç¨‹
lsof -i :5000  # Linux/Mac
netstat -ano | findstr :5000  # Windows

# ç»ˆæ­¢è¿›ç¨‹
kill -9 <PID>  # Linux/Mac
taskkill /PID <PID> /F  # Windows
é—®é¢˜3ï¼šä¾èµ–ç‰ˆæœ¬å†²çª
bash
# åˆ›å»ºå¹²å‡€ç¯å¢ƒ
conda create -n intent_new python=3.8
conda activate intent_new
pip install --upgrade pip
pip install -r requirements.txt
ğŸ“Š ç¬¬åä¸€ç« ï¼šæµ‹è¯•ä¸éªŒè¯
11.1 å•å…ƒæµ‹è¯•
bash
# è¿è¡Œæµ‹è¯•
python -m pytest tests/

# æµ‹è¯•è¦†ç›–ç‡
pytest --cov=src tests/
11.2 APIæµ‹è¯•
python
# ä½¿ç”¨pytestè¿›è¡ŒAPIæµ‹è¯•
def test_predict_endpoint():
    response = client.post('/predict', 
                          json={'text': 'æµ‹è¯•æ–‡æœ¬'})
    assert response.status_code == 200
    assert 'intent' in response.json()['data']
ğŸ“ˆ ç¬¬åäºŒç« ï¼šé¡¹ç›®æ‰©å±•æ–¹å‘
12.1 åŠŸèƒ½æ‰©å±•
å¤šè¯­è¨€æ„å›¾è¯†åˆ«

æƒ…æ„Ÿåˆ†æé›†æˆ

å®ä½“è¯†åˆ«ç»“åˆ

å¯¹è¯çŠ¶æ€è·Ÿè¸ª

12.2 æ¶æ„å‡çº§
å¾®æœåŠ¡æ¶æ„æ‹†åˆ†

æ¨¡å‹ç‰ˆæœ¬ç®¡ç†

A/Bæµ‹è¯•æ¡†æ¶

è‡ªåŠ¨æ¨¡å‹æ›´æ–°

12.3 éƒ¨ç½²ä¼˜åŒ–
Kubernetesé›†ç¾¤éƒ¨ç½²

è‡ªåŠ¨æ‰©ç¼©å®¹

å¤šåŒºåŸŸéƒ¨ç½²

ç¾å¤‡æ–¹æ¡ˆ

ğŸ“ é™„å½•ï¼šå¿«é€Ÿå‘½ä»¤å‚è€ƒ
A. å¼€å‘æµç¨‹
bash
# 1. å¯åŠ¨å¼€å‘ç¯å¢ƒ
source venv_intent/bin/activate

# 2. è®­ç»ƒæ¨¡å‹
python train.py

# 3. å¯åŠ¨API
python api/app.py

# 4. æµ‹è¯•è°ƒç”¨
python api/request_example.py
B. ç”Ÿäº§éƒ¨ç½²
bash
# 1. å®‰è£…gunicorn
pip install gunicorn

# 2. åå°è¿è¡Œ
nohup gunicorn -w 4 -b 0.0.0.0:5000 api.app:app &

# 3. æŸ¥çœ‹æ—¥å¿—
tail -f nohup.out
C. å¥åº·æ£€æŸ¥è„šæœ¬
bash
#!/bin/bash
# health_check.sh
API_URL="http://localhost:5000"

# æ£€æŸ¥æœåŠ¡çŠ¶æ€
curl -s "$API_URL/health" | grep -q "healthy"
if [ $? -eq 0 ]; then
    echo "âœ… æœåŠ¡è¿è¡Œæ­£å¸¸"
else
    echo "âŒ æœåŠ¡å¼‚å¸¸"
    exit 1
fi